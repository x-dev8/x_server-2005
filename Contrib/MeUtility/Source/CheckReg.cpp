#include "CheckReg.h"
#include <windows.h>

#pragma warning ( push, 0 )
extern "C"
{
#include "miracl.h"
}

namespace CheckReg
{
	DWORD GetDiskSerialNo()
	{
		LPCTSTR lpRootPathName="c:\\"; //取C盘的序列号
		char lpVolumeNameBuffer[64]="";//磁盘卷标

		DWORD VolumeSerialNumber;//磁盘序列号
		DWORD MaximumComponentLength;
		char lpFileSystemNameBuffer[64]="";
		DWORD nFileSystemNameSize=10;
		DWORD FileSystemFlags;
		GetVolumeInformation(lpRootPathName,
			lpVolumeNameBuffer, sizeof(lpVolumeNameBuffer),
			&VolumeSerialNumber, &MaximumComponentLength,
			&FileSystemFlags,
			lpFileSystemNameBuffer, nFileSystemNameSize);
		VolumeSerialNumber^=0x230123;//做一转换, 别让人一眼就看出是磁盘序列号
		if ( VolumeSerialNumber == 0 )
		{
			VolumeSerialNumber = 3599525745;
		}
		return VolumeSerialNumber;
	}


	bool CheckReg( char* szId )
	{
		if ( !szId || szId[0] == 0 )
		{
			return false;
		}
		//P(HEX)=D0E2E70FCEDB8AD9B1A653423B19A790BD2F31918202AFD7E16F2114F6AE016D96AB6135B596DF4EC77B403C158564A177461EBC727F00F78240C3927EEAE9A3081A305CFD120C28F479A09DFF38852165EE13DF96AA1136CA01B0CDED8A92FE14BECBAA0AE7E47AA9B19B211D9683878E22E32A86905E56FF74FF49D568F54983E351E3F143E1F542FFB2A1D2974825454FC56EDF43E7363DADF2B7F2C38C611363F1B6416B07671BAF52BFDB6D251DAF8A2C9A5187472DE6B8C37C3F893E187AB3AE9468E6BEBBDDDADD805631E2D97941F9FBCD0E5F3F195580882E55F311B8C1E771A129678883D0C5670A2D5EAA285074D33EA7475F878B208DB277007B
		//Q(HEX)=BFA3B104AEDFF19B4466B0E4AFB9874665DC38530CF256CF58C1F0E0A5CA0CBADC9525D8E46C536271558F67F657C7E95628548B234097C6E6D2807A4CFFA248F832D39FA000B9CC7F46E5E18D8AE1182B1208720763CC6048F03B1274D7D8E49CED9EA307AE0EC97CBE61585611C216F315ED5FCB6CA78F90FBB6440C6E1B2DA46BBFB383633F86809DB1385BE5F73BB0EDD253960A31E3FABFAC94488A06F5CC7C929359DDA58BC797D43D6DF933CC06E7D24715565661B590BE90A64935A6582C23348E82C802D6C9F69F278C521C37C1B472CD9F14C7623F50D0B495CCDEE130EFAD181A1D3A8B7E1840A7E4BA322DBA8107EDED164C9FC40CC4EE66ED6B
		//N(HEX)=9C5EDB4E9E65007F2CAC264BE6048EBA39439F9204F2C742112048EB137C62CE20468337B8DA36D7985E9640FB18E3CAAD570EC250D4F486DB1C0BD8B72F11A591E9AA672D91BA0BDB47920D15B1609E9147B3774398D0FD6C906207A18D51558B8B9B9F73F4C9E9960AC35F0C79D5197C494D499662228E089B6E27690605C4F126BB6128554A4F3F11569D664BBFC58EF52F8245EB0C2D74D64C8BA3ADE052BD7B8EEAA6BCE49AEA142063FAC0DF761F88655D11D11D1A93426F40751F86E53A8B57E9D14F29F8107ABD5AB2B713EEA37F1128AF4998D52B4962BB5DEFA674033EDD3A5B069AB15ECD70B50D589F6FD5F804CED13B7FBA4689D7A00BD2A4885990654B904CE322C5B05C3F28B0556611F01BBFDF21E97C00E559222824CA86775D1415AF2866363D367C4B7F975C6CC205AAA85022AEA463B0A5E1653739C794EF21C9AC23B68F7886A6D756B6C3F94E1DE8D6FFC89F6BE1D65C5A82BF0226D07AB012F3FF3B4FE8D41FC4E322B56DD383334023988A2666D24AB3AAD951C4EE691ABA705E27DC233531A71416D5469B30E25AE2752C081749AFBE96C661C197E95F54C6E2E42ABA7181D5F9F572414958A11C718C1DDA0BF7B8802D8886601B83A1D5927567D2D952293E8A5C74277BDEAE4DE84386FE08BA61E0798FBDFB82C4AF4A7D6F0CE2F010B10C4CFD3081644E68EA0DAF72E322F7A97A4E311269
		//D(HEX)=1E0AC14BDD61A0E23D64439A5A38C0C41CC93E4511FCFF7BA5C26F62CAF850A2C6172898719B7C7A111CA9402659E5CF6F9E6AE9E7DA7EC44714DF3B0E57371DB5346369D692973481346C660DD601CF5CE230209BDF43BCEDE0E5E602158442AB2DA9E864A1C88864BA67FEE7C27890D6B7F516B2D2D6EF93334619A79E2156ECD27C71CE38AEFCC9456A07A87257254AD46A826784EC32880193E4D17B459EFBEB3A94475B272514ECCF34A8F91935094FD0C251B56C944F744435A4F53863A0053C83D7021057365D5AFF6AD3D627EF94539F3F44BC6CD0EC4D475F3B70EA025D53A3BBEC8868CE478CA3DDCD44020FD0A3F45214F6412480B5396A938390FD6BD6828C34CE85ABD3E6D0DD57D8C6C1B36B31DFEF1A338EEE0AD5886D721F0A13B9D12E37BE2907CE303922C9C50C830E550540B97697A3315BBE2C7F061B597BF974B2AABAFE2CB17BA202CE4BB5D19A9AB4D64259E534E6EEAA958B41706E190FF700394463D4EDA9962B20E4D7354E1CE53196156EDAEE3808F6DAE124863F11FC67573D26AD85A1F208A7BF04C266653F1EEB9DC51D7B5C1E428E3EF312537CEC048231795ECC30CB945DADACE34EE96BD5F013853953583DEFDE7F89CDEE6060E59C189F227D29A185297466B1847EE2D36457537CCF57CCB3EC7EAE32FAB26F2EF32042E7CF43EB78D9BB9EEBF21835560BF05B354D5E392153A57F
		//E(HEX)=2466B
		//Keysize(Bits)=4096
		miracl *mip=mirsys(600,0);
		mip->IOBASE=16;	//16进制模式

		//定义并初始化变量
		big m=mirvar(0);	//m 放明文：注册码SN
		big c=mirvar(0);	//c 放密文：用户名Name
		big n=mirvar(0);	//n 模数
		big e=mirvar(0);	//e 公钥
		char Name[256]={0};
		char temp[1024]={0};
		int len=0;
		int i,j;

		//获取Name
		_snprintf( Name, sizeof(Name)-1, "%lu", GetDiskSerialNo() );
		len=strlen(Name);

		//获取SN
		len=strlen(szId);

		//检查SN是否为16进制
		for (i=0,j=0;i<len;i++)
		{
			if(isxdigit(szId[i])==0)
			{
				j=1;
				break;
			}
		}

		//如果输入的SN为16进制且长度不为0
		if (j!=1&&len!=0)
		{

			cinstr(m,szId);									//初始化明文m
			cinstr(n,"9C5EDB4E9E65007F2CAC264BE6048EBA39439F9204F2C742112048EB137C62CE20468337B8DA36D7985E9640FB18E3CAAD570EC250D4F486DB1C0BD8B72F11A591E9AA672D91BA0BDB47920D15B1609E9147B3774398D0FD6C906207A18D51558B8B9B9F73F4C9E9960AC35F0C79D5197C494D499662228E089B6E27690605C4F126BB6128554A4F3F11569D664BBFC58EF52F8245EB0C2D74D64C8BA3ADE052BD7B8EEAA6BCE49AEA142063FAC0DF761F88655D11D11D1A93426F40751F86E53A8B57E9D14F29F8107ABD5AB2B713EEA37F1128AF4998D52B4962BB5DEFA674033EDD3A5B069AB15ECD70B50D589F6FD5F804CED13B7FBA4689D7A00BD2A4885990654B904CE322C5B05C3F28B0556611F01BBFDF21E97C00E559222824CA86775D1415AF2866363D367C4B7F975C6CC205AAA85022AEA463B0A5E1653739C794EF21C9AC23B68F7886A6D756B6C3F94E1DE8D6FFC89F6BE1D65C5A82BF0226D07AB012F3FF3B4FE8D41FC4E322B56DD383334023988A2666D24AB3AAD951C4EE691ABA705E27DC233531A71416D5469B30E25AE2752C081749AFBE96C661C197E95F54C6E2E42ABA7181D5F9F572414958A11C718C1DDA0BF7B8802D8886601B83A1D5927567D2D952293E8A5C74277BDEAE4DE84386FE08BA61E0798FBDFB82C4AF4A7D6F0CE2F010B10C4CFD3081644E68EA0DAF72E322F7A97A4E311269");	//初始化模数n	 
			cinstr(e,"2466B");								//初始化公钥e

			//当m<n时
			if(compare(m,n)==-1)
			{
				powmod(m,e,n,c);//计算c=m^e mod n
				big_to_bytes(len,c,temp,FALSE);//将c转换成数组写入temp
			}
			else
				j=1;
		}
		//释放内存
		mirkill(m);
		mirkill(c);
		mirkill(n);
		mirkill(e);
		mirexit();

		//对Name、temp， m、n， SN的长度进行检查
		if(lstrcmp(Name,temp)!=0||j==1||len==0)
		{
			return false;
		}
		else
		{
			return true;
		}
	}

	bool IsReged()
	{
		char	szKey[1025];
		memset( szKey, 0, sizeof(szKey) );

		FILE* fp = fopen( "reg.key", "r" );
		if ( fp )
		{
			int nReadNum = fread( szKey, sizeof(char), 1024, fp );
			fclose( fp );
			if ( nReadNum != 0 )
			{
				if( CheckReg( szKey ) == false )
				{
					return false;
				}
				else
				{
					return true;

				}
			}
		}
		return false;
	}

	class Launch
	{
	public:
		Launch()
		{
			if( IsReged() == false )
			{
				char msg[256];
				_snprintf( msg, sizeof(msg)-1, "请找平台拿许可文件\n文件许可号: %u", GetDiskSerialNo() );
				MessageBox( NULL, msg, "", MB_OK );
				
				int *p = 0;
				*p = 12;
			}
		}
	};
}

#ifndef _DEBUG
CheckReg::Launch launck;
#endif

#pragma warning ( pop )